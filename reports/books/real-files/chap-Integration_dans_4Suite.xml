<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" 
                      "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
                      
<chapter id="integration_dans_4suite">
	<title>Intégration dans 4Suite</title>

  <para>
    Ce chapitre va présenter en détail le travail réalisé lors de ce projet. Nous commencerons par une présentation du module 4Suite et plus particulièrement de 4XSLT qui constitue notre base de travail. Ensuite nous introduirons les différents rajouts que nous réalisés ainsi que la manière dont ils s'intègrent dans 4Suite.
  </para>

	<section>
		<title>Présentation du module 4Suite</title>
		<para>
		  4Suite est une suite d'outils de traitement XML. Elle est implémentée en Python avec certaines extensions critiques en C. 
		</para>
		<para>
		  Le noyau de 4Suite est une bilbiothèque d'outils intégrés et de programmes en ligne commande associés pour le traitement de documents XML. Il implémente des technologies ouvertes telles que DOM, RDF, XSLT, XInclude, XPointer, XLink, XPath, XUpdate, RELAX NG, et XML/SGML Catalogues. Au dessus de celà, repose un serveur et un dépot de données XML et RDF.
		</para>
		<para>
		  4Suite est organisé en modules (c'est à dire des paquetages au sens Python) et d'une bibliothèque commune (<emphasis>Ft.lib</emphasis>). Les principaux autres modules sont : 
		</para>
		<itemizedlist>
		  <listitem>
		    <para>
		      4XML (<emphasis>Ft.Xml</emphasis>). C'est le module de premier niveau regroupant les autres modules et offrant les fonctions de gestion DOM, le lecteur écrivain SAX, le catalogue XML et les recommandations XUpdate (mise à jour de documents XML) et XInclude (transclusion de documents).
		    </para>
		  </listitem>
		  <listitem>
		    <para>
		      4Xpath (<emphasis>Ft.Xml.XPath</emphasis>). Ce module gère la lecture et l'analyse des expressions XPath qui peuvent-être présentes dans des documents XSLT ou XUpdate. Il retourne un arbre d'évaluation de l'expression lors de l'analyse de celle-ci. A noter qu'une partie de ce module est codé en langage C lui assurant une grande vélocité.
		    </para>
		  </listitem>
      <listitem>
        <para>
          4XSLT (<emphasis>Ft.Xml.Xslt</emphasis>). C'est le principal module que nous allons utiliser. Il gère la norme XSLT 1.0 de manière quasi complète. Il composé d'un ensemble de classes (une pour chaque élément XSLT), d'un processeur de transformation et d'écrivains DOM et Sax.
        </para>
        <para>
                          <figure>
                 <title>Diagramme des paquetages 4Suite</title>
                 <mediaobject>
                     <imageobject><imagedata format="PNG" fileref="images/Packages 4Suite.png"/></imageobject>
                 </mediaobject>
                </figure>
        </para>
      </listitem>
		</itemizedlist>
		<section>
		  <title>4XML</title>
		  <para>
		    Ce module est donc le module de plus haut niveau de la bibliothèque 4Suite. Il fournit les fonctionnalités de base pour le traitement XML, i.e. la lecture et l'écriture de documents. Ces opérations sont disponible via deux API : une semblable à DOM nommée Domlette et une semblable à Sax nommée Saxlette. Ces deux interfaces ne se réclament pas conforme totalement aux spécifications qui leur sont relatives puisqu'elles implémentent celles-ci dans une "pythonic way".
		  </para>
		</section>
		<section>
		  <title>4XPath</title>
		  <para>
		    Le module 4Xpath est un sous module du module 4Xml. Il est décomposé en deux parties : une partie analyse d'une expression XPath qui retourne un arbre d'évaluation et une partie recherche selon cet arbre d'évaluation qui permet de récupérer les noeuds Domlette qui correspondent à une expression XPath précédement analysé. Seuls la partie analyse sera utilisé dans la partie règle de ré-évaluation afin de récupérer l'arbre d'évaluation d'une expression XPath et ainsi réaliser nos traitements sur les instructions de mise en correspondance ("match").
		  </para>
		</section>
		<section>
		  <title>4XSLT</title>
		  <para>
		    Ce module est aussi un sous module de 4Xml. Il est composé d'un ensemble de classes étendant la classe XsltElement et qui implémentent le comportement de chacun des éléments XSLT 1.0. Il possède aussi ses propres écrivains Domlette et Saxlette qui ont la capacité d'écrire des fragments de documents XML. Cette écriture par fragment est obligatoire étant donné le comportement d'une transformation XSLT. Il dispose aussi d'un lecteur de feuille XSLT qui est en réalité un lecteur SAX particulier pour créer l'arbre de la feuille de transformation. Ensuite il définit une classe de contexte ("XsltContext") qui étend le context d'évaluation d'une expression XPath. Ce contexte est passé entre appel de la méthode d'instanciation de chaque élément XSLT lors de la transformation. Enfin, le processeur de traitement est aussi définit ici sous la forme d'une classe 
		  </para>
		  <para>
                <figure>
                 <title>Diagrame de classes XSLT</title>
                 <mediaobject>
                     <imageobject><imagedata format="PNG" fileref="images/Classes 4Xslt.png"/></imageobject>
                 </mediaobject>
                </figure>
		  </para>
		</section>
	</section>
	
	<section>
	  <title>Greffon incrémental</title>
	  <para>
	    Notre travail consiste en la réalisation de ce greffon. Notre objectif était de le réaliser sans avoir à intervenir sur le code de 4Suite afin d'en être relativement indépendant. Cela signifiait qu'il ne nous fallait ni modifier ce code, ni effectuer de copier-coller de comportement, sans quoi nous n'étions plus dépendant de l'API seule mais aussi de l'implémentation. Pour ce faire, il nous a fallu mettre en oeuvre de nouveaux paradigmes de programmation, à savoir la programmation par aspect.
	  </para>
	  <section>
	    <title>Wrapping des éléments DOM</title>
            <para>
  		4Suite utilise une implémentation DOM nommée Domlette, cette dernière est complète et propose même l'évaluation d'expressions XPath. Elle est réalisée en langage C lui-même encapsulé dans des classes Python pour des questions de performances. Cette dernière caractéristique entraîne quelques limitations, en particulier le fait que l'on ne puisse pas modifier dynamiquement, à l'exécution, le comportement des classe. Or ceci nous est nécessaire afin d'augmenter cette implémentation de DOM d'un comportement de type "Observeur/Observable". Après prise de contact avec l'auteur principal de 4Suite : "Uche Ogbuji" il s'avère que la meilleure solution est d'encapsuler les instances DOM dans des enveloppes nous permettant ainsi de greffer nos traitements spécifiques. On parle de "wrapping".
	    </para>
                <figure>
                 <title>Wrapping des éléments DOM</title>
                 <mediaobject>
                     <imageobject><imagedata format="PNG" fileref="images/Wrapping.png"/></imageobject>
                 </mediaobject>
                </figure>
            <para>
		Le wrapping réalisé dans ce projet repose en grande partie sur l'introspection possible avec Python. Une instance "CustomDomElement" est une enveloppe pour une instance de "cDomELement". Chaque appel visant à récupérer la valeur d'un attribut effectué sur l'instance enveloppe se retrouve repercuté sur l'instance envelloppée et renvoi si necessaire une instance elle-aussi enveloppée. Afin de renvoyer la même instance sur deux appels consécutifs de "firstChild()" par exemple, l'instance enveloppe dispose d'un tableau associant le resultat de l'appel "firstChild()" sur l'objet enveloppé avec le premier objet renvoyé par l'enveloppe.</para>
            <para>          
 Chaque appel visant à définir la valeur d'un attribut effectué sur l'instance enveloppe se retrouve repercuté sur l'instance enveloppée et lance un evenement indiquant que l'objet à changé d'état.
	    </para>
            <para>
              Tout ceci est possible et aisément réalisable grâce aux caractéristiques du langage Python, en particulier cette dernière : tout appel réalisé sur une instance, par exemple "monObjet.nom" est traduit par un appel "monObjet.__getattr__('nom')". De la même façon tout appel du type "monObjet.nom = "monNom" est traduit par un appel "monObjet.__setattr__('nom','monNom')". Par conséquent il suffit de redéfinir ces méthodes pour transformer le comportement intrinsèque de l'objet.
            </para>
            <para> Ces instances étant aux coeur de tous les traitements on peut qualifier le wrapping de point critique de l'implémentation. Afin de s'assurer de sa correction un certain nombre de tests unitaires ont été rédigés pour cette classe.         
            </para>
	  </section>
	  <section>
	    <title>Mémorisation du contexte</title>
	     <para>
	       La mémorisation du contexte est une étape essentielle pour réaliser le traitement incrémentale. Rappelons que l'exécution d'une transformation XSLT produit un arbre d'exécution dont les noeuds sont le contexte d'exécution d'une règle. XSLT étant un langage sans effet de bords, les contextes d'exécution ne sont dépendant que de la liste de ses ancêtres. Lors de l'exécution d'une transformation incrémentale, l'idée est donc de récupérer le contexte qui a servi à créer les noeuds du document cible en rapport avec le ou les noeuds modifiés dans le document source. Pour effectuer cette récupération, il est donc essentiel de conserver cet arbre de contexte.
	     </para>
	     <para>
	       TODO: schema montrant la dépendance du contexte avec le noeud source et cible
	     </para>
	     <para>
	       Lors de l'exécution d'une transformation, un processus dit d'instanciation se produit. Ce processus d'instanciation est en réalité l'exécution d'un noeud de traitement XSLT tel que "xsl:value-of". Ce processus réalise une copie du contexte courant, effectue le traitement avec le nouveau contexte (qui peut lui-même être copié si d'autres traitements sont effectués dans la suite) et retourne dans le programme principal avec l'ancien contexte. 
	     </para>
	     <para>
	       En résumé, il nous fallait pouvoir récupérer le contexte avant l'appel de la méthode "instanciate()" de tout les éléments XSLT qui modifiait ce contexte<footnote><para>La liste de ces éléments a été précisé dans le rapport de réalisation, nous ne la répéterons donc pas ici.</para></footnote>. Cette récupération s'est faite grâce à un aspect de mémorisation que l'on pourrait caractérisé de memoizing<footnote><para>Issue de la programmation dynamique, le memoizing est une technique qui consiste à stocker les résultats d'une fonction pour ré-utilisation ultérieure.</para></footnote>. Nous avons donc tissé cet aspect sur toutes les méthodes "instanciate()" des éléments XSLT de production. Pour des raisons de commodités, nous avons stocké ce contexte dans les règles de ré-évaluations que nous allons présenter ci-après.
	     </para>
	  </section>
	  <section>
	    <title>Règles de ré-évaluation</title>
	    <para>
	       TODO : règles de reevaluation.
	    </para>
	  </section>
	  <section>
	    <title>Le processeur incrémental</title>
	    <para>
	      Le processeur incrémental est une surcharge (par héritage) du processeur de transformation XSLT présent dans 4Suite. C'est lui qui portera principalement le comportement incrémental de l'application. Afin de lui permettre de détecter les modifications qui ont lieu sur les noeuds du document source, le processeur incrémental est aussi un observateur qui écoute les noeuds et qui est averti de toute modification.
	    </para>
	    <para>
	      Lorsqu'une modification intervient, la méthode "update()" du processeur est appelé. A ce momemt la, il faut testé si le noeud a été supprimé du document ou seulement modifié. Dans le cas ou il est supprimé, ce noeud est rajouté dans la liste des noeud modifié et marqué comme étant effacer. Dans le cas où il est juste supprimer, il est seulement ajouté dans cette liste. Ces opérations peuvent intervenir plusieurs fois d'affilé. Les noeuds modifiés / supprimés sont donc ajouter à la liste des modifications.
	    </para>
	    <para>
	      Lorsque la transformation incrémentale est exécuté via la méthode "runNodeInc()", le processeur teste la présence de modifications dans la liste précédement citée. Si elle est vide, il ne fais rien (sic). Dans le cas contraire, il parcours cette liste en vérifiant si chaque élément correspond à une règle de ré-évaluation. Dans ce cas, il est retraiter via l'appel de la méthode instanciate() propre à la règle de ré-évaluation. Le résultat est ensuite intégré au document cible.
	    </para>
	    <para>
	      Enfin, les noeuds à supprimer sont parcourus et les noeuds cibles dont ils dépendent sont supprimer. 
	    </para>
	    <para>
                <figure>
                 <title>Intégration du processeur incrémental avec 4Suite (diagramme de classes)</title>
                 <mediaobject>
                     <imageobject><imagedata format="PNG" fileref="images/Classes Processor inc.png"/></imageobject>
                 </mediaobject>
                </figure>	      
	    </para>
	  </section>
	</section>

</chapter>
