<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" 
                      "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">
                      
<chapter id="integration_dans_4suite">
	<title>Intégration dans 4Suite</title>

  <para>
    TODO : Introduction...
  </para>

	<section>
		<title>Présentation du module 4Suite</title>
		<para>
		  4Suite est une suite d'outils de traitement XML. Elle est implémentée en Python avec certaines extensions critiques en C. 
		</para>
		<para>
		  Le noyau de 4Suite est une bilbiothèque d'outils intégrés et de programmes en ligne commande associés pour le traitement de documents XML. Il implémente des technologies ouvertes telles que DOM, RDF, XSLT, XInclude, XPointer, XLink, XPath, XUpdate, RELAX NG, et XML/SGML Catalogues. Au dessus de celà, repose un serveur et un dépot de données XML et RDF.
		</para>
		<para>
		  4Suite est organisé en modules (c'est à dire des paquetages au sens Python) et d'une bibliothèque commune (<emphasis>Ft.lib</emphasis>). Les principaux autres modules sont : 
		</para>
		<itemizedlist>
		  <listitem>
		    <para>
		      4XML (<emphasis>Ft.Xml</emphasis>). C'est le module de premier niveau regroupant les autres modules et offrant les fonctions de gestion DOM, le lecteur écrivain SAX, le catalogue XML et les recommandations XUpdate (mise à jour de documents XML) et XInclude (transclusion de documents).
		    </para>
		  </listitem>
		  <listitem>
		    <para>
		      4Xpath (<emphasis>Ft.Xml.XPath</emphasis>). Ce module gère la lecture et l'analyse des expressions XPath qui peuvent-être présentes dans des documents XSLT ou XUpdate. Il retourne un arbre d'évaluation de l'expression lors de l'analyse de celle-ci. A noter qu'une partie de ce module est codé en langage C lui assurant une grande vélocité.
		    </para>
		  </listitem>
      <listitem>
        <para>
          4XSLT (<emphasis>Ft.Xml.Xslt</emphasis>). C'est le principal module que nous allons utiliser. Il gère la norme XSLT 1.0 de manière quasi complète. Il composé d'un ensemble de classes (une pour chaque élément XSLT), d'un processeur de transformation et d'écrivains DOM et Sax.
        </para>
      </listitem>
		</itemizedlist>
		<section>
		  <title>4XML</title>
		  <para>
		    Ce module est donc le module de plus haut niveau de la bibliothèque 4Suite. Il fournit les fonctionnalités de base pour le traitement XML, i.e. la lecture et l'écriture de documents. Ces opérations sont disponible via deux API : une semblable à DOM nommée Domlette et une semblable à Sax nommée Saxlette. Ces deux interfaces ne se réclament pas conforme totalement aux spécifications qui leur sont relatives puisqu'elles implémentent celles-ci dans une "pythonic way".
		  </para>
		  <para>
		    TODO : diagramme 4XML Domlette et Saxlette
		  </para>
		</section>
		<section>
		  <title>4XPath</title>
		  <para>
		  
		  </para>
		</section>
		<section>
		  <title>4XSLT</title>
		</section>
	</section>
	
	<section>
	  <title>Greffon incrémental</title>
	  <para>
	    TODO : introduction greffon incrementale
	  </para>
	  <section>
	    <title>Wrapping des éléments DOM</title>
            <para>
  		4Suite utilise une implémentation DOM nommée Domlette, cette dernière est complète et propose même l'évaluation d'expressions XPath. Elle est réalisée en langage C lui-même encapsulé dans des classes Python pour des questions de performances. Cette dernière caractéristique entraîne quelques limitations, en particulier le fait que l'on ne puisse pas modifier dynamiquement, à l'exécution, le comportement des classe. Or ceci nous est nécessaire afin d'augmenter cette implémentation de DOM d'un comportement de type "Observeur/Observable". Après prise de contact avec l'auteur principal de 4Suite : "Uche Ogbuji" il s'avère que la meilleure solution est d'encapsuler les instances DOM dans des enveloppes nous permettant ainsi de greffer nos traitements spécifiques. On parle de "wrapping".
	    </para>
                <figure>
                 <title>Wrapping des éléments DOM</title>
                 <mediaobject>
                     <imageobject><imagedata format="PNG" fileref="images/Wrapping.png"/></imageobject>
                 </mediaobject>
                </figure>
            <para>
		Le wrapping réalisé dans ce projet repose en grande partie sur l'introspection possible avec Python. Une instance "CustomDomElement" est une enveloppe pour une instance de "cDomELement". Chaque appel visant à récupérer la valeur d'un attribut effectué sur l'instance enveloppe se retrouve repercuté sur l'instance envelloppée et renvoi si necessaire une instance elle-aussi enveloppée. Afin de renvoyer la même instance sur deux appels consécutifs de "firstChild()" par exemple, l'instance enveloppe dispose d'un tableau associant le resultat de l'appel "firstChild()" sur l'objet enveloppé avec le premier objet renvoyé par l'enveloppe.</para>
            <para>          
 Chaque appel visant à définir la valeur d'un attribut effectué sur l'instance enveloppe se retrouve repercuté sur l'instance enveloppée et lance un evenement indiquant que l'objet à changé d'état.
	    </para>
            <para>
              Tout ceci est possible et aisément réalisable grâce aux caractéristiques du langage Python, en particulier cette dernière : tout appel réalisé sur une instance, par exemple "monObjet.nom" est traduit par un appel "monObjet.__getattr__('nom')". De la même façon tout appel du type "monObjet.nom = "monNom" est traduit par un appel "monObjet.__setattr__('nom','monNom')". Par conséquent il suffit de redéfinir ces méthodes pour transformer le comportement intrinsèque de l'objet.
            </para>
            <para> Ces instances étant aux coeur de tous les traitements on peut qualifier le wrapping de point critique de l'implémentation. Afin de s'assurer de sa correction un certain nombre de tests unitaires ont été rédigés pour cette classe.         
            </para>
	  </section>
	  <section>
	    <title>Mémorisation du contexte</title>
	     <para>
	       La mémorisation du contexte est une étape essentielle pour réaliser le traitement incrémentale. Rappelons que l'exécution d'une transformation XSLT produit un arbre d'exécution dont les noeuds sont le contexte d'exécution d'une règle. XSLT étant un langage sans effet de bords, les contextes d'exécution ne sont dépendant que de la liste de ses ancêtres. Lors de l'exécution d'une transformation incrémentale, l'idée est donc de récupérer le contexte qui a servi à créer les noeuds du document cible en rapport avec le ou les noeuds modifiés dans le document source. Pour effectuer cette récupération, il est donc essentiel de conserver cet arbre de contexte.
	     </para>
	     <para>
	       TODO: schema montrant la dépendance du contexte avec le noeud source et cible
	     </para>
	     <para>
	       Lors de l'exécution d'une transformation, un processus dit d'instanciation se produit. Ce processus d'instanciation est en réalité l'exécution d'un noeud de traitement XSLT tel que "xsl:value-of". Ce processus réalise une copie du contexte courant, effectue le traitement avec le nouveau contexte (qui peut lui-même être copié si d'autres traitements sont effectués dans la suite) et retourne dans le programme principal avec l'ancien contexte. 
	     </para>
	     <para>
	       En résumé, il nous fallait pouvoir récupérer le contexte avant l'appel de la méthode "instanciate()" de tout les éléments XSLT qui modifiait ce contexte<footnote><para>La liste de ces éléments a été précisé dans le rapport de réalisation, nous ne la répéterons donc pas ici.</para></footnote>. Cette récupération s'est faite grâce à un aspect de mémorisation que l'on pourrait caractérisé de memoizing<footnote><para>Issue de la programmation dynamique, le memoizing est une technique qui consiste à stocker les résultats d'une fonction pour ré-utilisation ultérieure.</para></footnote>. Nous avons donc tissé cet aspect sur toutes les méthodes "instanciate()" des éléments XSLT de production. Pour des raisons de commodités, nous avons stocké ce contexte dans les règles de ré-évaluations que nous allons présenter ci-après.
	     </para>
	  </section>
	  <section>
	    <title>Règles de ré-évaluation</title>
	  </section>
	  <section>
	    <title>Le processeur incrémental</title>
	  </section>
	</section>

</chapter>
