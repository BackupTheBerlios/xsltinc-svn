<chapter id="Recherche_documentaire" ><title>
Recherche documentaire</title>
<section id="XPath" ><title>
XPath</title>
<section id="Introduction" ><title>
Introduction</title>
<section id="Historique" ><title>
Historique</title>
<para>XPath est un standard du W3C défini en 1999. Il a été créée dans le but d&apos;avoir une syntaxe commune pour XPointer et les transformations XSLT.</para>
<para>Son nom vient du fait que les expressions XPath sont semblables aux &quot;chemins&quot; que l&apos;on distingue dans les URL par exemple.</para>

</section>

<section id="Objectif" ><title>
Objectif</title>
<para>&quot;XPath permet la sélection d&apos;un ensemble de noeuds dans un arbre XML. On obtient alors un sous arbre de l&apos;arbre source. </para>
<para>XPath fourni également quelques fonctions basiques de traitement de chaînes de caractères, de nombre ou de booléens.  XPath opère sur la structure logique, abstraite, des données XML et non pas sur la syntaxe de ce dernier.</para>
<para>En plus de ces opérations XPath permet également de définir des règles de filtrage, ou encore &quot;matching&quot;, pour chaque noeud du source XML on va pouvoir dire si il est apparié ou pas au chemin XPath. Ceci est principalement utilisé dans les transformations XSLT.</para>

</section>


</section>

<section id="Modele_conceptuel" ><title>
Modèle conceptuel</title>
<para></para>
<para></para>
<section id="7_types_de_noeuds" ><title>
7 types de noeuds</title>
<para>XPath opère sur des données XML arborescentes. Cet arbre est composé de noeuds, on en distingue 7 types:</para>
<itemizedlist>
<listitem><para>
Les noeuds racines</para></listitem>
<listitem><para>
Les noeuds d&apos;éléments</para></listitem>
<listitem><para>
Les noeuds de texte</para></listitem>
<listitem><para>
Les noeuds d&apos;attributs</para></listitem>
<listitem><para>
Les noeuds d&apos;espaces de nommage</para></listitem>
<listitem><para>
Les noeuds d&apos;instructions de traitement</para></listitem>
<listitem><para>
Les noeuds de commentaires</para></listitem>
</itemizedlist>
<para>Ainsi dans l&apos;exemple suivant :</para>
<para><programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;bookstore&gt;&lt;book&gt;&lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt;&lt;author&gt;J K. Rowling&lt;/author&gt;&lt;year&gt;2005&lt;/year&gt;&lt;price&gt;29.99&lt;/price&gt;&lt;/book&gt;&lt;/bookstore&gt;</programlisting></para>
<para>Le noeud racine est &quot;&lt;bookstore&gt;&quot;, &quot;&lt;author&gt;J K. Rowling&lt;/author&gt;&quot; est un noeud d&apos;élément et &quot;lang=&quot;en&quot;&quot; un noeud d&apos;attribut.</para>

</section>

<section id="Relations_entre_les_noeuds" ><title>
Relations entre les noeuds</title>
<para>On distingue également plusieurs types de relation entre les noeuds.</para>
<itemizedlist>
<listitem><para>
Parents : chaque noeud élément ou d&apos;attribut à un parent.</para></listitem>
<listitem><para>
Children : les noeuds d&apos;élément peuvent avoir aucun, un ou plus d&apos;un enfant.</para></listitem>
<listitem><para>
Siblings : les noeuds qui ont le mème parent</para></listitem>
<listitem><para>
Ancestors : le parent du noeud, son parent, etc etc..</para></listitem>
<listitem><para>
Descendants : l&apos;enfant, son enfant, etc etc..</para></listitem>
<listitem><para>
</para></listitem>
</itemizedlist>

</section>

<section id="Expressions" ><title>
Expressions</title>
<para>Une expression peut être composé de plusieurs sous-expression, chacune pouvant être de type:</para>
<itemizedlist>
<listitem><para>
les appels de fonction.</para></listitem>
<listitem><para>
les ensembles de noeuds : lorsque l&apos;on indique un chemin au sein d&apos;une expression celui-ci est évalué comme l&apos;ensemble des noeuds correspondants.</para></listitem>
<listitem><para>
les booléens : qui peuvent être &quot;vrai&quot; ou &quot;faux&quot;, ils peuvent être le résultat de l&apos;évaluation d&apos;un opérateur.</para></listitem>
<listitem><para>
les nombres </para></listitem>
<listitem><para>
les chaînes de caractères</para></listitem>
<listitem><para>
les structures lexicales : parenthèses et regroupements de termes.</para></listitem>
</itemizedlist>

</section>


</section>

<section id="Fonctionnement" ><title>
Fonctionnement</title>
<para>Le principe de XPath est le suivant : on définit un sous ensemble de l&apos;arbre par la concaténation d&apos;un chemin auquel on peut associer un prédicat. </para>
<para>Ce principe de base peut ensuite être utilisé autant de fois que nécessaire afin de sélectionner les données désirées.</para>
<para></para>
<section id="Un_chemin" ><title>
Un chemin</title>
<para>Il s&apos;agit de l&apos;élément de syntaxe le plus important. Tout noeud d&apos;un arbre XML peut être identifié de manière unique à l&apos;aide d&apos;un chemin. Il peut alors être très verbeux.</para>
<para>Un chemin est composé d&apos;une ou plusieurs étapes séparées par un &apos;/&apos;.</para>
<para>Un chemin peut être qualifié d&apos;absolu ou de relatif. Le fonctionnement est le même que dans le cadre des système de fichiers sous Unix. </para>
<para>Par exemple, le noeud suivant <programlisting>child::chapter/descendant::para</programlisting></para>
<para> sélectionne l&apos;élément &quot;para&quot; descendant de l&apos;élément &quot;chapter&quot; fils du noeud courant.</para>
<para>Un chemin relatif est constitué d&apos;une ou plusieurs étapes séparées par &apos;/&apos; . Chaque étape sélectionne  un ensemble de noeud par rapport au contexte d&apos;évaluation du chemin. Ce contexte change à chaque fois et correspond au dernier ensemble de noeuds sélectionné.</para>
<para>Un chemin absolu commence par &apos;/&apos; qui peut être suivi ou non par une suite d&apos;étapes. Le &apos;/&apos; représente le noeud racine du document source.</para>
<para>Par exemple <programlisting>/chapter</programlisting> qui sélectionne les chapitres dont le parent est la racine du document</para>

</section>

<section id="Une_etape" ><title>
Une étape</title>
<para>L&apos;étape est l&apos;élément fondamental du chemin ,elle est composée de trois parties :</para>
<itemizedlist>
<listitem><para>
un axe : qui définit le type de relation entre les noeuds sélectionnés par l&apos;étape et le noeud courant.</para></listitem>
<listitem><para>
un test de noeud : qui spécifie le type de noeud que l&apos;on souhaite sélectionner.</para></listitem>
<listitem><para>
aucun, un ou plusieurs prédicats qui utilisent des expressions arbitraires afin de raffiner la sélection des noeuds.</para></listitem>
</itemizedlist>
<para>La syntaxe d&apos;une étape est donc tout d&apos;abord le nom de l&apos;axe, suivi du test de noeud, tous deux séparés par &apos;::&apos;, ce dernier suivi des prédicats entre crochets &apos;[]&apos;.</para>
<para>Voici un exemple :</para>
<para><programlisting>child::para[position()=1]</programlisting></para>
<para>L&apos;ensemble de noeuds sélectionnés par une étape est donc l&apos;ensemble de noeuds généré par l&apos;axe associé au test de noeud qui serait par la suite filtré par le ou les prédicats.</para>

</section>

<section id="Un_axe" ><title>
Un axe</title>
<para>Un axe définit un ensemble de noeuds de manière relative au noeud courant. Les axes utilisent les relations hiérarchiques entre les noeuds.</para>
<para>On identifie les axes suivant :</para>
<itemizedlist>
<listitem><para>
ancestor : les ancêtres du noeud courant, autrement dit son parent, le parent de son parent et ainsi de suite jusqu&apos;à la racine du document.</para></listitem>
<listitem><para>
ancestor-or-self : les ancêtres auquel ont ajoute le noeud courant.</para></listitem>
<listitem><para>
attribute : tous les attributs du noeud courant.</para></listitem>
<listitem><para>
child : les noeuds dont le noeud courant est le noeud père.</para></listitem>
<listitem><para>
descendant : tous les descendants du noeud courant.</para></listitem>
<listitem><para>
descendant-or-self : les descendants auxquels on ajoute le noeud courant.</para></listitem>
<listitem><para>
following : tous les noeuds que l&apos;on trouve après la fermeture du noeud courant.</para></listitem>
<listitem><para>
following-sibling : les noeuds ayant le même parent que le noeud courant et le suivant.</para></listitem>
<listitem><para>
namespace : tous les noeuds d&apos;espace de nommage du noeud courant.</para></listitem>
<listitem><para>
parent : le parent du noeud courant.</para></listitem>
<listitem><para>
preceding : tous les noeuds que l&apos;on trouve avant le noeud courant.</para></listitem>
<listitem><para>
preceding-sibling :  les noeuds ayant le même parent que le noeud courant et le précédant.</para></listitem>
<listitem><para>
self : le noeud courant.</para></listitem>
<listitem><para>
</para></listitem>
</itemizedlist>
<figure>
<title>Axe XPath - ancêtres</title>
<mediaobject><imageobject><imagedata format="PNG" fileref="pics/pic-33.png"/>
<!--file:///home/t0rt00se/Travail/SILR3/pTrans/xsltinc/reports/books/bm-files/images/xpath-axe.png-->
<!--pic-33.png-->
</imageobject></mediaobject> </figure>

</section>

<section id="Les_tests_de_noeuds" ><title>
Les tests de noeuds</title>
<para>Le test de noeud spécifie le type du noeud et le nom des noeuds obtenus par l&apos;étape de localisation.</para>
<figure>
<title>XPath - Test de noeud &quot;Person&quot;</title>
<mediaobject><imageobject><imagedata format="PNG" fileref="pics/pic-34.png"/>
<!--file:///home/t0rt00se/Travail/SILR3/pTrans/xsltinc/reports/books/bm-files/images/xpath-nodetype.png-->
<!--pic-34.png-->
</imageobject></mediaobject> </figure>

</section>

<section id="Les_predicats" ><title>
Les prédicats</title>
<para>Un prédicat filtre un ensemble de noeud selon l&apos;axe spécifié afin de produire un nouvel ensemble de noeud. Pour chaque noeud l&apos;expression du prédicat est évaluée, si l&apos;évaluation renvoie &quot;vrai&quot; alors le noeud est gardé dans l&apos;ensemble résultant, dans le cas contraire il est rejeté.</para>
<para></para>
<para>Si le résultat de l&apos;évaluation est un nombre alors l&apos;expression sera considérée comme &apos;vrai&apos; si le nombre obtenu est le même que la position courante dans l&apos;arbre, à &apos;faux&apos; autrement.</para>
<para></para>

</section>

<section id="La_syntaxe_reduite" ><title>
La syntaxe réduite</title>
<para>Il existe une syntaxe réduite afin de limiter la verbosité de XPath.</para>
<para>Le raccourcis le plus important est que l&apos;on peut omettre le</para>
<para> &lt;programlisting&gt;child::&lt;/programlisting&gt;</para>
<para>dans une étape, ainsi</para>
<para> &lt;programlisting&gt;child::div/child::para&lt;/programlisting&gt;</para>
<para>peut aussi être écrit </para>
<para>&lt;programlisting&gt;div/para&lt;/programlisting&gt;.</para>
<para>De la même façon </para>
<para>&lt;programlisting&gt;attribute::&lt;/programlisting&gt;</para>
<para>peut être remplacé par &quot;@&quot; ce qui nous donne</para>
<para>&lt;programlisting&gt;[@type=&quot;warning&quot;]&lt;/programlisting&gt;</para>
<para>au lieu de </para>
<para>&lt;programlisting&gt;child::para[attribute::type=&quot;warning&quot;]&lt;/programlisting&gt;</para>
<para>L&apos;expression &apos;//&apos; est un raccourcis pour l&apos;axe &lt;programlisting&gt;descendant-or-self::node()&lt;/programlisting&gt;</para>
<para>De la même façon &quot;..&quot; est un raccourci pour l&apos;axe </para>
<para>&lt;programlisting&gt;parent::node()&lt;/programlisting&gt;.</para>

</section>


</section>


</section>

</chapter>
