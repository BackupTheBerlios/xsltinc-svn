<chapter id="Recherche_documentaire" >
	<title>Recherche documentaire</title>
	
	<para>
		Dans ce chapitre nous allons détailler les différents aspects techniques et technologiques ayant trait à notre projet. Nous nous efforcerons à expliquer chaque point complexe et chaque acronyme. En cas d'oubli pour les acronymes, nous invitons le lecteur à se référer à la <xref linkend="glossary" xrefstyle="template:section %t page %p"/>.
	</para>
	
	<section>
		<title>Les technologies du W3C</title>
	
		<para>
			Le W3C<footnote><para>World Wide Web Consortium.</para></footnote> n'est pas un orgnanisme officiel ; il ne peut donc prétendre éditer des normes ou des standards. C'est pourquoi un document final du W3C est appelé <emphasis>Recommendation</emphasis>, terme qui peut sembler un peu bizarre au premier abord. Mais une <emphasis>Recommendation</emphasis> du W3C n'a rien à voir avec un recueil de conseils, et c'est un document qui équivaut de fait à un standard, rédigé dans le style classique des spécifications. Dans toute la suite, nous parlerons néanmoins de standards XML et XSLT, même si ce ne sont pas des standards au sens officiel du terme.
		</para>
	
		<section>
			<title>eXtensible Markup Language, XML</title>
			<para>
				Défini par le W3C, le XML permet de définir ses propres formats de données. C'est pour cela que l'on considère plutôt le XML comme un méta-langage permettant de définir des nouveaux langages, ou dialectes. Les développeurs peuvent alors stocker des informations en toute liberté. De cette dernière aurait pu naître une confusion encore plus grande qu'elle ne l'était déjà, mais des langages permettant de décrire la structure d'un document XML ont été  repris, comme les DTDs (Document Type Definition) ou créé de toute pièce comme le XML Schema. Ainsi, des applications hétérogènes peuvent communiquer avec un format parfaitement adapté aux données qu'elles échangent en se mettant d'accord sur le langage utilisé.
			</para>
			<para>
				Le XML est un langage extensible utilisant des balises. Il n'utilise que du texte brute généralement encodé au format Unicode<footnote><para>Unicode est un standard informatique développé par le Consortium Unicode qui vise à donner à tout caractère de n'importe quel système d'écriture de langue un identifiant numérique, et ce de manière unifiée, quelle que soit la plate-forme informatique ou le logiciel.</para></footnote>. La  structure d'un document XML est hiérarchique et arborescente et est donc aussi facilement interprétable par un humain que par un programme informatique. La particularité qui fais de XML un langage d'échange universel est son dépendance vis-à-vis des plates-formes matérielles, des systèmes d'exploitations, des langages qui l'utilisent et des protocoles qui le transportent. Ce caractère lui a permis de grandement se développer des les technologies web où règne l'hétérogénéité.
			</para>
			<para>Le XML est né du SGML (Standard Generalized Markup Language) et HTML (HyperText Markup Language). Il reprit les meilleurs idées de chacun de ces langages. Le SGML, apparu en 1986, était très complet et lourd. Il était destiné aux grands systèmes de gestion documentaires et à l'impression. De plus, cette n'époque n'était pas encore très souciante de la question du multisupport. Le HTML quant à lui est destiné à la publication en ligne sur l'internet. Son système de balisage concerne essentiellement la mise en forme (gras, italique, couleurs...). Le HTML a pour avantage d'être léger et souple mais aussi d'apporter la possibilité de naviguer à l'intérieur et à l'extérieur des documents grâce aux liens et aux ancres.
			</para>
			<para>
				Bien que très utilisés, ces deux langages n'en restaient pas moins très spécialisés, le premier à l'impression, le second à la publication en ligne. Il fallait de ce fait déterminer à l'avance ce que l'on voulait faire d'un document : l'imprimer ou le rendre accessible sur l'internet. Si l'on voulait changer de medium, il fallait réaliser des adaptations lourdes et coûteuses.
			</para>
			<para>
				Aujourd'hui, le multi-support est devenu commun : on imprime dans différents formats en fonction du client, on diffuse sur l'internet et on créé des résumés pour les bases documentaires. Comment faire alors pour ne pas avoir multiplier le fond d'un document tout en ayant plusieurs formes ? XML est né de ce désir de disposer d'un texte structuré sémantiquement qui permette facilement ensuite de le publier sur différents media. La mise en forme en elle-même est réalisée par des feuilles de style CSS (Cascading Style Sheet) ou XSL (eXtensible Stylesheet Language). Cela implique tout de même quelques contraintes, notamment que la sémantique autour des données soit assez poussée pour effectuer de tels traitements. Un exemple [<xref linkend="exHTML" xrefstyle="select:label"/>] vaut mieux qu'un long discours.
			</para>
			<example id="exHTML">
				<title>Un exemple basique en HTML</title>
				<programlisting><![CDATA[<i>Camelia sinensis</i>]]></programlisting>
			</example>
			<para>La balise <![CDATA[<i>]]> met le texte en italique. En XML, on essaierai plutôt de mettre du sens sur ce terme afin de le formatter en conséquence [<xref linkend="exXML1" xrefstyle="select:label"/>], ou mieux encore, en utilisant des attributs [<xref linkend="exXML2" xrefstyle="select:label"/>].
			</para>
			<example id="exXML1">
				<title>Un exemple basique en XML</title>
				<programlisting><![CDATA[<nom-botanique-latin>
  Camelia sinensis
</nom-botanique-latin>]]></programlisting>
			</example>
			<example id="exXML2">
				<title>Un exemple avec des attributs en XML</title>
				<programlisting><![CDATA[<nom domaine="botanique" langue="latin">
  Camelia sinensis
</nom>]]></programlisting>
			</example>
			<para>
				Dans ce dernier exemple, une feuille de style XSL pourra transformer le document XML en HTML en précisant que tous les noms de botanique latin doivent être en italique. D'une part il sera possible de changer <foreignphrase>a posteriori</foreignphrase> cette mise en forme puisqu'elle se base sur la sémantique du document XML et d'autre part de donner un autre aspect (caractères gras et rouge) lors d'une autre transformation, en PDF<footnote><para>Portable Document Format (traduit littéralement par "format portable de documents"), est un format de fichier informatique créé par la société Adobe Systems.</para></footnote>.
			</para>
			<para>
				Il n'est pas question ici d'alourdir le document, de noyer les informations, mais de rajouter de la sémantique plutôt que mettre le terme en simple italique. Il s'agit de pouvoir envisager la forme qu'au moment de la publication et de pouvoir retrouver rapidement des données dans le texte. Ainsi, si le texte doit être traduit dans une autre langue, nous aurons l'avantage de savoir que ce terme est latin et qu'il ne se traduit donc pas.
			</para>
		</section>
	
		<section>
			<title>XSL</title>
			<para>
				XSL (eXtensible Stylesheet Language) est le langage de description de feuilles de style du W3C associé à XML. Une feuille de style XSL est un fichier qui décrit comment doivent être présentés (c'est-à-dire affichés, imprimés, épelés…) les documents XML basés sur une même DTD ou un même schéma. La spécification est divisée en trois parties :
			</para>
			
			<itemizedlist>
			<listitem>
				<para>
					<emphasis role="strong">XPath</emphasis>, le langage de navigation 
					dans un document XML.
				</para>
			</listitem>			
			<listitem>
				<para>
					<emphasis role="strong">XSLT</emphasis>, le langage de transformation.
				</para>
			</listitem>
			<listitem>
				<para>
					<emphasis role="strong">XSL-FO</emphasis>, le vocabulaire XML de mise 
					en forme (non détaillé dans ce document).
				</para>
			</listitem>
			</itemizedlist>
			
<section id="XPath" ><title>
XPath</title>
<section id="Introduction" ><title>
Introduction</title>
<section id="Historique" ><title>
Historique</title>
<para>XPath est un standard du W3C défini en 1999. Il a été créée dans le but d&apos;avoir une syntaxe commune pour XPointer et les transformations XSLT.</para>
<para>Son nom vient du fait que les expressions XPath sont semblables aux &quot;chemins&quot; que l&apos;on distingue dans les URL par exemple.</para>

</section>

<section id="Objectif" ><title>
Objectif</title>
<para>&quot;XPath permet la sélection d&apos;un ensemble de noeuds dans un arbre XML. On obtient alors un sous arbre de l&apos;arbre source. </para>
<para>XPath fourni également quelques fonctions basiques de traitement de chaînes de caractères, de nombre ou de booléens.  XPath opère sur la structure logique, abstraite, des données XML et non pas sur la syntaxe de ce dernier.</para>
<para>En plus de ces opérations XPath permet également de définir des règles de filtrage, ou encore &quot;matching&quot;, pour chaque noeud du source XML on va pouvoir dire si il est apparié ou pas au chemin XPath. Ceci est principalement utilisé dans les transformations XSLT.</para>

</section>


</section>

<section id="Modele_conceptuel" ><title>
Modèle conceptuel</title>
<para></para>
<para></para>
<section id="7_types_de_noeuds" ><title>
7 types de noeuds</title>
<para>XPath opère sur des données XML arborescentes. Cet arbre est composé de noeuds, on en distingue 7 types:</para>
<itemizedlist>
<listitem><para>
Les noeuds racines</para></listitem>
<listitem><para>
Les noeuds d&apos;éléments</para></listitem>
<listitem><para>
Les noeuds de texte</para></listitem>
<listitem><para>
Les noeuds d&apos;attributs</para></listitem>
<listitem><para>
Les noeuds d&apos;espaces de nommage</para></listitem>
<listitem><para>
Les noeuds d&apos;instructions de traitement</para></listitem>
<listitem><para>
Les noeuds de commentaires</para></listitem>
</itemizedlist>
<para>Ainsi dans l&apos;exemple suivant :</para>
<para><programlisting><![CDATA[<?xml version="1.0" encoding="ISO-8859-1"?>
<bookstore>
  <book>
    <title lang="en">Harry Potter</title>
    <author>J K. Rowling</author>
    <year>2005</year>
    <price>29.99</price>
  </book>
</bookstore>]]></programlisting></para>
<para>Le noeud racine est &quot;&lt;bookstore&gt;&quot;, &quot;&lt;author&gt;J K. Rowling&lt;/author&gt;&quot; est un noeud d&apos;élément et &quot;lang=&quot;en&quot;&quot; un noeud d&apos;attribut.</para>

</section>

<section id="Relations_entre_les_noeuds" ><title>
Relations entre les noeuds</title>
<para>On distingue également plusieurs types de relation entre les noeuds.</para>
<itemizedlist>
<listitem><para>
Parents : chaque noeud élément ou d&apos;attribut à un parent.</para></listitem>
<listitem><para>
Children : les noeuds d&apos;élément peuvent avoir aucun, un ou plus d&apos;un enfant.</para></listitem>
<listitem><para>
Siblings : les noeuds qui ont le mème parent</para></listitem>
<listitem><para>
Ancestors : le parent du noeud, son parent, etc etc..</para></listitem>
<listitem><para>
Descendants : l&apos;enfant, son enfant, etc etc..</para></listitem>
<listitem><para>
</para></listitem>
</itemizedlist>

</section>

<section id="Expressions" ><title>
Expressions</title>
<para>Une expression peut être composé de plusieurs sous-expression, chacune pouvant être de type:</para>
<itemizedlist>
<listitem><para>
les appels de fonction.</para></listitem>
<listitem><para>
les ensembles de noeuds : lorsque l&apos;on indique un chemin au sein d&apos;une expression celui-ci est évalué comme l&apos;ensemble des noeuds correspondants.</para></listitem>
<listitem><para>
les booléens : qui peuvent être &quot;vrai&quot; ou &quot;faux&quot;, ils peuvent être le résultat de l&apos;évaluation d&apos;un opérateur.</para></listitem>
<listitem><para>
les nombres </para></listitem>
<listitem><para>
les chaînes de caractères</para></listitem>
<listitem><para>
les structures lexicales : parenthèses et regroupements de termes.</para></listitem>
</itemizedlist>

</section>


</section>

<section id="Fonctionnement" ><title>
Fonctionnement</title>
<para>Le principe de XPath est le suivant : on définit un sous ensemble de l&apos;arbre par la concaténation d&apos;un chemin auquel on peut associer un prédicat. </para>
<para>Ce principe de base peut ensuite être utilisé autant de fois que nécessaire afin de sélectionner les données désirées.</para>
<para></para>
<section id="Un_chemin" ><title>
Un chemin</title>
<para>Il s&apos;agit de l&apos;élément de syntaxe le plus important. Tout noeud d&apos;un arbre XML peut être identifié de manière unique à l&apos;aide d&apos;un chemin. Il peut alors être très verbeux.</para>
<para>Un chemin est composé d&apos;une ou plusieurs étapes séparées par un &apos;/&apos;.</para>
<para>Un chemin peut être qualifié d&apos;absolu ou de relatif. Le fonctionnement est le même que dans le cadre des système de fichiers sous Unix. </para>
<para>Par exemple, le noeud suivant <programlisting>child::chapter/descendant::para</programlisting></para>
<para> sélectionne l&apos;élément &quot;para&quot; descendant de l&apos;élément &quot;chapter&quot; fils du noeud courant.</para>
<para>Un chemin relatif est constitué d&apos;une ou plusieurs étapes séparées par &apos;/&apos; . Chaque étape sélectionne  un ensemble de noeud par rapport au contexte d&apos;évaluation du chemin. Ce contexte change à chaque fois et correspond au dernier ensemble de noeuds sélectionné.</para>
<para>Un chemin absolu commence par &apos;/&apos; qui peut être suivi ou non par une suite d&apos;étapes. Le &apos;/&apos; représente le noeud racine du document source.</para>
<para>Par exemple <programlisting>/chapter</programlisting> qui sélectionne les chapitres dont le parent est la racine du document</para>

</section>

<section id="Une_etape" ><title>
Une étape</title>
<para>L&apos;étape est l&apos;élément fondamental du chemin ,elle est composée de trois parties :</para>
<itemizedlist>
<listitem><para>
un axe : qui définit le type de relation entre les noeuds sélectionnés par l&apos;étape et le noeud courant.</para></listitem>
<listitem><para>
un test de noeud : qui spécifie le type de noeud que l&apos;on souhaite sélectionner.</para></listitem>
<listitem><para>
aucun, un ou plusieurs prédicats qui utilisent des expressions arbitraires afin de raffiner la sélection des noeuds.</para></listitem>
</itemizedlist>
<para>La syntaxe d&apos;une étape est donc tout d&apos;abord le nom de l&apos;axe, suivi du test de noeud, tous deux séparés par &apos;::&apos;, ce dernier suivi des prédicats entre crochets &apos;[]&apos;.</para>
<para>Voici un exemple :</para>
<para><programlisting>child::para[position()=1]</programlisting></para>
<para>L&apos;ensemble de noeuds sélectionnés par une étape est donc l&apos;ensemble de noeuds généré par l&apos;axe associé au test de noeud qui serait par la suite filtré par le ou les prédicats.</para>

</section>

<section id="Un_axe" ><title>
Un axe</title>
<para>Un axe définit un ensemble de noeuds de manière relative au noeud courant. Les axes utilisent les relations hiérarchiques entre les noeuds.</para>
<para>On identifie les axes suivant :</para>
<itemizedlist>
<listitem><para>
ancestor : les ancêtres du noeud courant, autrement dit son parent, le parent de son parent et ainsi de suite jusqu&apos;à la racine du document.</para></listitem>
<listitem><para>
ancestor-or-self : les ancêtres auquel ont ajoute le noeud courant.</para></listitem>
<listitem><para>
attribute : tous les attributs du noeud courant.</para></listitem>
<listitem><para>
child : les noeuds dont le noeud courant est le noeud père.</para></listitem>
<listitem><para>
descendant : tous les descendants du noeud courant.</para></listitem>
<listitem><para>
descendant-or-self : les descendants auxquels on ajoute le noeud courant.</para></listitem>
<listitem><para>
following : tous les noeuds que l&apos;on trouve après la fermeture du noeud courant.</para></listitem>
<listitem><para>
following-sibling : les noeuds ayant le même parent que le noeud courant et le suivant.</para></listitem>
<listitem><para>
namespace : tous les noeuds d&apos;espace de nommage du noeud courant.</para></listitem>
<listitem><para>
parent : le parent du noeud courant.</para></listitem>
<listitem><para>
preceding : tous les noeuds que l&apos;on trouve avant le noeud courant.</para></listitem>
<listitem><para>
preceding-sibling :  les noeuds ayant le même parent que le noeud courant et le précédant.</para></listitem>
<listitem><para>
self : le noeud courant.</para></listitem>
<listitem><para>
</para></listitem>
</itemizedlist>
<figure>
<title>Axe XPath - ancêtres</title>
<mediaobject><imageobject><imagedata format="PNG" fileref="images/pic-33.png"/>
<!--file:///home/t0rt00se/Travail/SILR3/pTrans/xsltinc/reports/books/bm-files/images/xpath-axe.png-->
<!--pic-33.png-->
</imageobject></mediaobject> </figure>

</section>

<section id="Les_tests_de_noeuds" ><title>
Les tests de noeuds</title>
<para>Le test de noeud spécifie le type du noeud et le nom des noeuds obtenus par l&apos;étape de localisation.</para>
<figure>
<title>XPath - Test de noeud &quot;Person&quot;</title>
<mediaobject><imageobject><imagedata format="PNG" fileref="images/pic-34.png"/>
<!--file:///home/t0rt00se/Travail/SILR3/pTrans/xsltinc/reports/books/bm-files/images/xpath-nodetype.png-->
<!--pic-34.png-->
</imageobject></mediaobject> </figure>

</section>

<section id="Les_predicats" ><title>
Les prédicats</title>
<para>Un prédicat filtre un ensemble de noeud selon l&apos;axe spécifié afin de produire un nouvel ensemble de noeud. Pour chaque noeud l&apos;expression du prédicat est évaluée, si l&apos;évaluation renvoie &quot;vrai&quot; alors le noeud est gardé dans l&apos;ensemble résultant, dans le cas contraire il est rejeté.</para>
<para></para>
<para>Si le résultat de l&apos;évaluation est un nombre alors l&apos;expression sera considérée comme &apos;vrai&apos; si le nombre obtenu est le même que la position courante dans l&apos;arbre, à &apos;faux&apos; autrement.</para>
<para></para>

</section>

<section id="La_syntaxe_reduite" ><title>
La syntaxe réduite</title>
<para>Il existe une syntaxe réduite afin de limiter la verbosité de XPath.</para>
<para>Le raccourcis le plus important est que l&apos;on peut omettre le</para>
<para> &lt;programlisting&gt;child::&lt;/programlisting&gt;</para>
<para>dans une étape, ainsi</para>
<para> &lt;programlisting&gt;child::div/child::para&lt;/programlisting&gt;</para>
<para>peut aussi être écrit </para>
<para>&lt;programlisting&gt;div/para&lt;/programlisting&gt;.</para>
<para>De la même façon </para>
<para>&lt;programlisting&gt;attribute::&lt;/programlisting&gt;</para>
<para>peut être remplacé par &quot;@&quot; ce qui nous donne</para>
<para>&lt;programlisting&gt;[@type=&quot;warning&quot;]&lt;/programlisting&gt;</para>
<para>au lieu de </para>
<para>&lt;programlisting&gt;child::para[attribute::type=&quot;warning&quot;]&lt;/programlisting&gt;</para>
<para>L&apos;expression &apos;//&apos; est un raccourcis pour l&apos;axe &lt;programlisting&gt;descendant-or-self::node()&lt;/programlisting&gt;</para>
<para>De la même façon &quot;..&quot; est un raccourci pour l&apos;axe </para>
<para>&lt;programlisting&gt;parent::node()&lt;/programlisting&gt;.</para>

</section>

</section>

			<section>
				<title>XSLT</title>
				<para>
					XSLT (eXtended Stylesheet Language Transformations), défini au sein de la recommandation XSL du W3C, est un langage de transformation XML de type fonctionnel. L'objectif principal est la transformation d'un document XML vers un autre, ou un dialecte XML (XHTML, XSL-FO, HTML, etc.). Cependant, le langage XSLT permet aussi les transformations vers tout autre type de document, au format texte ou dans un format binaire (bien que ceci ne soit pas nativement prévu par la recommandation XSLT). XSLT s'appuie sur XPath (une autre partie de la recommandation XSL) pour désigner une partie d'un arbre XML. XSLT est lui-même un dialecte XML. Un programme XSLT est donc, avant tout, un document XML.
				</para>
				<para>
	 				Le standard XSLT 1.0 est <foreignphrase>W3C Recommendation</foreignphrase> du 16 novembre 1999<footnote><para>voir http://www.w3.org/TR/xslt</para></footnote>. A noter que les attributs de certains éléments XML de ce langage contiennent des chaînes de caractères dont la syntaxe et la sémantique obéissent au langage XPath (cf. <xref linkend="exHTML" xrefstyle="select:label"/>)
				</para>
			</section>
	
		</section>
	</section>

</section>

</chapter>
